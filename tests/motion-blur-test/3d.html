<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <title>Tesserace 3D Motion Blur Test</title>

  <style type="text/css">
    canvas {
      float: left;
      background-color: #888;
    }

    img.hidden {
      position: absolute;
      visibility: hidden;
      overflow: hidden;
    }

    #controls {
      float: left;
      margin: 10px;
      font-size: 14px;
      width: 600px;
    }

    #brightnessSlider, #dofSpreadSlider, #focalLengthSlider, #environmentRotationSlider, #customGLSLText {
      width: 450px;
    }

    .h {
      font-size: 18px;
      font-weight: bold;
    }

    #statusContainer {
      position: absolute;
      left: 0;
      top: 0;
      width: 512px;
      height: 512px;
      text-align: center;
      vertical-align: middle;
      line-height: 512px;
    }

    #status {
      padding: 10px;
      background-color: rgba(255,255,255,0.5);
      border-radius: 10px;
    }

    #container {
      width: 1132px;
      margin: 0 auto;
      position: relative;
      top: 0;
      left: 0;
    }

    html, body {
      font-family: Helvetica, Helvetica Neue, Arial, sans-serif;
    }
  </style>

  <script src="../../lib/lodash-2.4.1.min.js"></script>
  <script type="text/javascript">
    var oldArray64 = window.Float64Array;
    window.Float64Array = window.Float32Array;
  </script>
  <script src="../../lib/dot.min.js"></script>
  <script type="text/javascript">
    window.Float64Array = oldArray64;
  </script>
</head>
<body>
  <div id="container">
    <div style="text-align: center;">
      <h1>Tesserace 3D Motion Blur Test</h1>
    </div>

    <div style="font-size: 16px; margin: 0 auto; width: 800px; line-height: 120%;">
      Rays are fired from the camera out into the scene, bounce around according to physical models, and record when they
      hit a light source. Whenever anything changes, the scene has to be re-traced (it starts out noisy, but converges
      to the correct image).
    </div>

    <div style="position: relative; top: 0; left: 0; margin-top: 20px;">
      <canvas id="canvas" width="512" height="512"></canvas>
      <div id="statusContainer"><span id="status">Loading ...</span></div>
    </div>

    <div id="controls">
      <p>
        <div class="h">Movement Controls</div>
        WASD for forwards/backwards/sideways motion, arrow keys to rotate, and Q/E to roll.
      </p>
      <p>
        <div class="h">Time (Soccer ball motion blur)</div>
        <label for="startTime">Start Time</label>
        <input autocomplete="off" id="startTimeSlider" name="startTime" type="range" min="0" max="50" value="0" step="0.1" />
        <br>
        <label for="shutterOpenTime">Shutter Open Time</label>
        <input autocomplete="off" id="shutterOpenTimeSlider" name="shutterOpenTime" type="range" min="0" max="30" value="0" step="0.1" />
      </p>
      <p>
        <div class="h">Tone Mapping</div>
        <label for="linearBox">
          <input autocomplete="off" type="radio" name="toneMap" id="linearBox" checked>Linear</input>
        </label>
        <label for="reinhardBox">
          <input autocomplete="off" type="radio" name="toneMap" id="reinhardBox">Reinhard</input>
        </label>
        <label for="filmicBox">
          <input autocomplete="off" type="radio" name="toneMap" id="filmicBox">Filmic</input>
        </label>
        <br>
        <label for="brightness">Exposure</label>
        <input autocomplete="off" id="brightnessSlider" name="brightness" type="range" min="0" max="500" value="100" step="1" />
      </p>
      <p>
        <div class="h">Depth of Field</div>
        (perspective only for now)<br>
        <label for="dofSpread">Blur Amount</label>
        <input autocomplete="off" id="dofSpreadSlider" name="dofSpread" type="range" min="0" max="500" value="0" step="1" />
        <br>
        <label for="focalLength">Focal Length</label>
        <input autocomplete="off" id="focalLengthSlider" name="focalLength" type="range" min="0" max="1000" value="150" step="0.5" />
      </p>
      <p>
        <div class="h">Projection</div>
        <label for="perspectiveBox">
          <input autocomplete="off" type="radio" name="projection" id="perspectiveBox" checked>Perspective</input>
        </label>
        <label for="stereographicBox">
          <input autocomplete="off" type="radio" name="projection" id="stereographicBox">Stereographic</input>
        </label>
      </p>
      <p>
        <div class="h">Mouse Control</div>
        <label for="mouseNoneBox">
          <input autocomplete="off" type="radio" name="mouseControl" id="mouseNoneBox">Nothing</input>
        </label>
        <br>
        <label for="mouseRotateBox">
          <input autocomplete="off" type="radio" name="mouseControl" id="mouseRotateBox" checked>Rotate (around focal point)</input>
        </label>
        <br>
        <label for="mouseFocusBox">
          <input autocomplete="off" type="radio" name="mouseControl" id="mouseFocusBox">Focus on point (when clicked or dragged)</input>
        </label>
        <br>
        <label for="mouseLightBox">
          <input autocomplete="off" type="radio" name="mouseControl" id="mouseLightBox">Light at point (when clicked or dragged)</input>
        </label>
        <br>
        <label for="mouseMakeDynamicBox">
          <input autocomplete="off" type="radio" name="mouseControl" id="mouseMakeDynamicBox">Drag spheres (not too many, shader uniforms limited)</input>
        </label>
      </p>
      <p>
        <div class="h">Environment</div>
        <label for="envConstantBox">
          <input autocomplete="off" type="radio" name="environmentControl" id="envConstantBox">Constant (white/gray)</input>
        </label>
        <br>
        <label for="envWeirdBox">
          <input autocomplete="off" type="radio" name="environmentControl" id="envWeirdBox">Custom GLSL Expression</input>
          <br>
          <input autocomplete="off" type="text" name="customGLSLText" id="customGLSLText" value="pow( abs( 1.0 + sin( 50.0 * asin( rayDir.x ) ) * sin( 50.0 * asin( rayDir.z ) ) ), 7.0 ) * 0.15" style="margin-left: 20px;"></input>
          <button id="updateCustomGLSLButton">Update</button>
        </label>
        <br>
        HDR Skies downsampled from <a href="http://www.viz-people.com/portfolio/free-hdri-maps/">Vizpeople's free (non-commercial) environment maps</a>:
        <br>
        <label for="envTest01">
          <input autocomplete="off" type="radio" name="environmentControl" id="envTest01">Sky 01 (2048x512)</input>
        </label>
        <label for="envTest01x">
          <input autocomplete="off" type="radio" name="environmentControl" id="envTest01x">(4096x1024)</input>
        </label>
        <br>
        <label for="envTest02">
          <input autocomplete="off" type="radio" name="environmentControl" id="envTest02">Sky 02 (2048x512)</input>
        </label>
        <label for="envTest02x">
          <input autocomplete="off" type="radio" name="environmentControl" id="envTest02x">(4096x1024)</input>
        </label>
        <br>
        <label for="envTest03">
          <input autocomplete="off" type="radio" name="environmentControl" id="envTest03">Sky 03 (2048x512)</input>
        </label>
        <label for="envTest03x">
          <input autocomplete="off" type="radio" name="environmentControl" id="envTest03x">(4096x1024)</input>
        </label>
        <br>
        <label for="envTest04">
          <input autocomplete="off" type="radio" name="environmentControl" id="envTest04" checked>Sky 04 (2048x512)</input>
        </label>
        <label for="envTest04x">
          <input autocomplete="off" type="radio" name="environmentControl" id="envTest04x">(4096x1024)</input>
        </label>
        <br>
        <label for="envTest05">
          <input autocomplete="off" type="radio" name="environmentControl" id="envTest05">Sky 05 (2048x512)</input>
        </label>
        <label for="envTest05x">
          <input autocomplete="off" type="radio" name="environmentControl" id="envTest05x">(4096x1024)</input>
        </label>
        <br>
        <label for="envTest06">
          <input autocomplete="off" type="radio" name="environmentControl" id="envTest06">Sky 06 (2048x512)</input>
        </label>
        <label for="envTest06x">
          <input autocomplete="off" type="radio" name="environmentControl" id="envTest06x">(4096x1024)</input>
        </label>
        <br>
        <label for="envTest07">
          <input autocomplete="off" type="radio" name="environmentControl" id="envTest07">Sky 07 (2048x512)</input>
        </label>
        <label for="envTest07x">
          <input autocomplete="off" type="radio" name="environmentControl" id="envTest07x">(4096x1024)</input>
        </label>
        <br>
        <label for="envTest08">
          <input autocomplete="off" type="radio" name="environmentControl" id="envTest08">Sky 08 (2048x512)</input>
        </label>
        <label for="envTest08x">
          <input autocomplete="off" type="radio" name="environmentControl" id="envTest08x">(4096x1024)</input>
        </label>
        <br>
        <label for="envTest09">
          <input autocomplete="off" type="radio" name="environmentControl" id="envTest09">Sky 09 (2048x512)</input>
        </label>
        <label for="envTest09x">
          <input autocomplete="off" type="radio" name="environmentControl" id="envTest09x">(4096x1024)</input>
        </label>
        <br>
        <label for="envTest10">
          <input autocomplete="off" type="radio" name="environmentControl" id="envTest10">Sky 10 (2048x512)</input>
        </label>
        <label for="envTest10x">
          <input autocomplete="off" type="radio" name="environmentControl" id="envTest10x">(4096x1024)</input>
        </label>
        <br>
        HDR Skies from <a href="hhttp://www.openfootage.net/">openfootage.net free (attribution) environment maps</a>:
        <br>
        <label for="envDusk2048Box">
          <input autocomplete="off" type="radio" name="environmentControl" id="envDusk2048Box">Dusk (2048x512)</input>
        </label>
        <br>
        <label for="environmentRotation">Rotation</label>
        <input autocomplete="off" id="environmentRotationSlider" name="environmentRotation" type="range" min="0" max="360" value="297" step="0.5" />
      </p>
      <p>
        <div class="h">Size</div>
        <button autocomplete="off" type="radio" name="sizeChoice" id="size256Box">256px</button>
        <button autocomplete="off" type="radio" name="sizeChoice" id="size512Box">512px</button>
        <button autocomplete="off" type="radio" name="sizeChoice" id="size1024Box">1024px</button>
      </p>
      <p>
        <div class="h">Future Thoughts</div>
      </p>
      <ul>
        <li>Scale down to other aspect ratios / non-power-of-2-sizes</li>
        <li>Other tone mapping options (Reinhard)?</li>
        <li>Filtering to remove aliasing</li>
        <li>Improved importance sampling</li>
        <li>Bloom shader (mipmap down, blur with separable kernel at each stage after thresholding for brightness).</li>
        <li>Variance output (<a href="http://www.johndcook.com/standard_deviation.html">trackable with 2 floats</a>).</li>
        <li>HDRI export (<a href="http://concord-consortium.github.io/lab/experiments/webgl-gpgpu/webgl.html">floating-point export workaround</a>).</li>
        <li>Distance fields for water glass (and consider elliptical acceleration). Milk with BSSRDF?</li>
        <li>Use textures and multi-pass for rendering many-triangled objects.</li>
        <li>Consider persistent texture for improved PRNG</li>
        <li>Spectral rendering, consider polarization and thin-film support for realistic camera model (with multipass!)</li>
        <li>4D experimentation</li>
      </ul>
      Like it? Send me your thoughts at <a id="email" href="mailto:jonathan.olson@colorado.edu">jonathan.olson@colorado.edu</a>
    </div>
  </div>

  <script type="text/javascript">
    var emailField = document.getElementById( 'email' );
    var emailAddress = 'jonathan.olson' + ( true ? '' : 'junk' ) + '@' + 'colorado.edu';
    emailField.href = 'mailto:' + emailAddress;
    emailField.innerHTML = emailAddress;

    function updateCanvasSize( size ) {
      if ( typeof size === 'string' ) {
        size = Number.parseInt( size );
      }
      document.getElementById( 'canvas' ).width = size;
      document.getElementById( 'canvas' ).height = size;
      document.getElementById( 'statusContainer' ).style.width = size + 'px';
      document.getElementById( 'statusContainer' ).style.height = size + 'px';
      document.getElementById( 'statusContainer' ).style.lineHeight = size + 'px';
      document.getElementById( 'container' ).style.width = ( size + 620 ) + 'px';
    }

    var sizeResults = /size=([^&#]+)/.exec( location.search );
    if ( sizeResults ) {
      updateCanvasSize( sizeResults[1] );
    }
  </script>

  <script src="tesserace.js"></script>
  <script src="snippets.js"></script>
  <script src="traceables3.js"></script>
  <script src="materials3.js"></script>
  <script src="scene3.js"></script>

  <script type="text/javascript">
    var vizpeopleEnvironments = {
      '01': { brightness: 3 },
      '02': { brightness: 3 },
      '03': { brightness: 3 },
      '04': { brightness: 3 },
      '05': { brightness: 3 },
      '06': { brightness: 20 },
      '07': { brightness: 3 },
      '08': { brightness: 3 },
      '09': { brightness: 3 },
      '10': { brightness: 3 }
    };

    function setStatus( message ) {
      var statusSpan = document.getElementById( 'status' );
      statusSpan.innerHTML = message;
      statusSpan.parentNode.style.display = message ? 'block' : 'none';
    }

    function initialize() {
      var gl = tess.gl;

      function loadWrapTex( htmlId ) {
        var img = document.getElementById( htmlId );

        var texture = gl.createTexture();
        gl.bindTexture( gl.TEXTURE_2D, texture );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR );
        gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, false );
        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img );
        gl.bindTexture( gl.TEXTURE_2D, null );
        document.body.removeChild( img );

        return texture;
      }

      var wallHeight = 60;
      var wallInner = 350;
      var wallOuter = 370;

      var startTime = 0;
      var shutterOpenTime = 0;

      var oak1DiffuseTexture = loadWrapTex( 'oak1-diffuse-2048' );
      var oak1DirtTexture = loadWrapTex( 'oak1-dirt-2048' );
      var oak1NormalTexture = loadWrapTex( 'oak1-dot3-4096' );

      var oakFloorMaterial = new tess.OakFloor( oak1DiffuseTexture, oak1DirtTexture, oak1NormalTexture, wallInner );
      var diffuseFloorMaterial = new tess.Diffuse();

      var floor = new tess.Plane( dot( 0, 1, 0 ), 0, false, oakFloorMaterial );
      floor.preventShadows = true;

      var sceneObs;
      var coffeeSceneObs;
      var testSceneObs;
      var colorSceneObs;
      var indoorSceneObs;

      var lightSphere = new tess.Sphere( dot( 0, -100, 10 ), 7, true, new tess.Emit( new tess.Absorb(), dot( 25, 25, 25 ), false ) );

      function setupCoffeeScene() {
        var ceiling = new tess.Box3( dot( -wallOuter, wallHeight, -wallOuter ), dot( wallOuter, wallHeight + 2, wallOuter ), false, new tess.Attenuate( new tess.Diffuse(), dot( 1, 1, 1 ), false ) );

        // TODO: add actual window/windows? (dielectric)
        var wall1 = new tess.Box3( dot( -wallOuter, 0, wallInner ), dot( wallOuter, wallHeight, wallOuter ), false, new tess.Attenuate( new tess.Diffuse(), dot( 0.9, 0.9, 0.9 ), false ) );
        var wall2 = new tess.Box3( dot( -wallOuter, 0, -wallOuter ), dot( wallOuter, wallHeight, -wallInner ), false, new tess.Attenuate( new tess.Diffuse(), dot( 0.9, 0.9, 0.9 ), false ) );
        var wall2x = new tess.Box3( dot( -2, wallHeight - 15, -wallOuter ), dot( 2, wallHeight, -wallInner ), false, new tess.Attenuate( new tess.Diffuse(), dot( 0.9, 0.9, 0.9 ), false ) );
        var wall3 = new tess.Box3( dot( -wallOuter, 0, -wallOuter ), dot( -wallInner, wallHeight, wallOuter ), false, new tess.Attenuate( new tess.Diffuse(), dot( 0.9, 0.9, 0.9 ), false ) );
        var wall4 = new tess.Box3( dot( wallInner, 0, -wallOuter ), dot( wallOuter, wallHeight, wallOuter ), false, new tess.Attenuate( new tess.Diffuse(), dot( 0.9, 0.9, 0.9 ), false ) );

        var coffeeTableHeight = 43;
        var coffeeTableGap = 0.001;
        var coffeeTableThickness = 0.5;
        var coffeeTableX = 0;
        var coffeeTableZ = 0;
        var coffeeTableHalfX = 25;
        var coffeeTableHalfZ = 45;
        var coffeeLeg = 5;
        var coffeeFront = coffeeTableZ + coffeeTableHalfZ;
        var coffeeBack = coffeeTableZ - coffeeTableHalfZ;
        var coffeeRight = coffeeTableX + coffeeTableHalfX;
        var coffeeLeft = coffeeTableX - coffeeTableHalfX;
        var glassTop = new tess.Box3( dot( coffeeLeft, coffeeTableHeight - coffeeTableThickness, coffeeBack ),
                                      dot( coffeeRight, coffeeTableHeight, coffeeFront ),
                                      false, new tess.SmoothDielectric( 1.6 ), true );
        var leg1 = new tess.Box3( dot( coffeeLeft, 0, coffeeBack ),
                                  dot( coffeeLeft + coffeeLeg, coffeeTableHeight - coffeeTableGap - coffeeTableThickness, coffeeBack + coffeeLeg ), false, new tess.ShinyBlack( 1.5167 )  );
        var leg2 = new tess.Box3( dot( coffeeRight - coffeeLeg, 0, coffeeBack ),
                                  dot( coffeeRight, coffeeTableHeight - coffeeTableGap - coffeeTableThickness, coffeeBack + coffeeLeg ), false, new tess.ShinyBlack( 1.5167 )  );
        var leg3 = new tess.Box3( dot( coffeeLeft, 0, coffeeFront - coffeeLeg ),
                                  dot( coffeeLeft + coffeeLeg, coffeeTableHeight - coffeeTableGap - coffeeTableThickness, coffeeFront ), false, new tess.ShinyBlack( 1.5167 )  );
        var leg4 = new tess.Box3( dot( coffeeRight - coffeeLeg, 0, coffeeFront - coffeeLeg ),
                                  dot( coffeeRight, coffeeTableHeight - coffeeTableGap - coffeeTableThickness, coffeeFront ), false, new tess.ShinyBlack( 1.5167 )  );

        var glassSphere = new tess.Sphere( dot( 0, coffeeTableHeight + 8, 25 ), 8, false, new tess.SmoothDielectric( 1.5 ), true );
        var blackSphere = new tess.Sphere( dot( 0, coffeeTableHeight + 8, 0 ), 8, false, new tess.ShinyBlack( 1.5167 ) );
        var greenSphere = new tess.Sphere( dot( 0, coffeeTableHeight + 8, -25 ), 8, false, new tess.FresnelCompositeMaterial( new tess.Reflect(), new tess.Attenuate( new tess.Diffuse(), dot( 0.1, 1, 0.1 ), false ), tess.airIOR, 1.33 ) );
        var soccer = new tess.Sphere( dot( -20, 11, -10 ), 11, false, new tess.SoccerMaterial() );

        coffeeSceneObs = [
          floor,
          wall1,
          wall2,
          wall3,
          wall4,
          glassTop,
          leg1,
          leg2,
          leg3,
          leg4,
          lightSphere,
          glassSphere,
          blackSphere,
          greenSphere,
          soccer
        ];
      }
      function useCoffeeScene() {
        floor.material = oakFloorMaterial;
        sceneObs = coffeeSceneObs;
        updateSampleProgram();
      }

      function setupTestScene() {
        var ceiling = new tess.Box3( dot( -wallOuter, wallHeight, -wallOuter ), dot( wallOuter, wallHeight + 2, wallOuter ), false, new tess.Attenuate( new tess.Diffuse(), dot( 1, 1, 1 ), false ) );

        // TODO: add actual window/windows? (dielectric)
        var wall1 = new tess.Box3( dot( -wallOuter, 0, wallInner ), dot( wallOuter, wallHeight, wallOuter ), false, new tess.Attenuate( new tess.Diffuse(), dot( 0.9, 0.9, 0.9 ), false ) );
        var wall2 = new tess.Box3( dot( -wallOuter, 0, -wallOuter ), dot( wallOuter, wallHeight, -wallInner ), false, new tess.Attenuate( new tess.Diffuse(), dot( 0.9, 0.9, 0.9 ), false ) );
        var wall2x = new tess.Box3( dot( -2, wallHeight - 15, -wallOuter ), dot( 2, wallHeight, -wallInner ), false, new tess.Attenuate( new tess.Diffuse(), dot( 0.9, 0.9, 0.9 ), false ) );
        var wall3 = new tess.Box3( dot( -wallOuter, 0, -wallOuter ), dot( -wallInner, wallHeight, wallOuter ), false, new tess.Attenuate( new tess.Diffuse(), dot( 0.9, 0.9, 0.9 ), false ) );
        var wall4 = new tess.Box3( dot( wallInner, 0, -wallOuter ), dot( wallOuter, wallHeight, wallOuter ), false, new tess.Attenuate( new tess.Diffuse(), dot( 0.9, 0.9, 0.9 ), false ) );

        var coffeeTableHeight = 43;
        var coffeeTableGap = 0.001;
        var coffeeTableThickness = 0.5;
        var coffeeTableX = 0;
        var coffeeTableZ = 0;
        var coffeeTableHalfX = 25;
        var coffeeTableHalfZ = 45;
        var coffeeLeg = 5;
        var coffeeFront = coffeeTableZ + coffeeTableHalfZ;
        var coffeeBack = coffeeTableZ - coffeeTableHalfZ;
        var coffeeRight = coffeeTableX + coffeeTableHalfX;
        var coffeeLeft = coffeeTableX - coffeeTableHalfX;
        var glassTop = new tess.Box3( dot( coffeeLeft, coffeeTableHeight - coffeeTableThickness, coffeeBack ),
                                      dot( coffeeRight, coffeeTableHeight, coffeeFront ),
                                      false, new tess.SmoothDielectric( 1.6 ), true );
        // var leg1 = new tess.Box3( dot( -4, 0, -4 ), dot( -3.5, 2.99, -3.5 ), false, new tess.Metal( dot( 1.26232, 7.1855 ) ) ); // like aluminum
        var leg1 = new tess.Box3( dot( coffeeLeft, 0, coffeeBack ),
                                  dot( coffeeLeft + coffeeLeg, coffeeTableHeight - coffeeTableGap - coffeeTableThickness, coffeeBack + coffeeLeg ), false, new tess.ShinyBlack( 1.5167 )  );
        var leg2 = new tess.Box3( dot( coffeeRight - coffeeLeg, 0, coffeeBack ),
                                  dot( coffeeRight, coffeeTableHeight - coffeeTableGap - coffeeTableThickness, coffeeBack + coffeeLeg ), false, new tess.ShinyBlack( 1.5167 )  );
        var leg3 = new tess.Box3( dot( coffeeLeft, 0, coffeeFront - coffeeLeg ),
                                  dot( coffeeLeft + coffeeLeg, coffeeTableHeight - coffeeTableGap - coffeeTableThickness, coffeeFront ), false, new tess.ShinyBlack( 1.5167 )  );
        var leg4 = new tess.Box3( dot( coffeeRight - coffeeLeg, 0, coffeeFront - coffeeLeg ),
                                  dot( coffeeRight, coffeeTableHeight - coffeeTableGap - coffeeTableThickness, coffeeFront ), false, new tess.ShinyBlack( 1.5167 )  );

        var testOb = new tess.TestObject( new tess.SmoothDielectric( 1.5 ) );


        testSceneObs = [
          floor,
          wall1,
          wall2,
          wall3,
          wall4,
          glassTop,
          lightSphere,
          leg1,
          leg2,
          leg3,
          leg4,
          testOb
        ];
      }
      function useTestScene() {
        floor.material = oakFloorMaterial;
        sceneObs = testSceneObs;
        updateSampleProgram();
      }

      function setupColorScene() {
        function diffuseBox( center, color ) {
          return new tess.Box3( center.plus( dot( -10, -10, -10 ) ), center.plus( dot( 10, 10, 10 ) ), false, new tess.Attenuate( new tess.Diffuse(), color, false ) );
        }
        function glassBox( center ) {
          return new tess.Box3( center.plus( dot( -10, -10, -10 ) ), center.plus( dot( 10, 10, 10 ) ), false, new tess.SmoothDielectric( 1.5 ), true );
        }

        colorSceneObs = [
          floor,
          diffuseBox( dot( 0, 35, 0 ), dot( 0.1, 0.1, 0.1 ) ),
          diffuseBox( dot( 0, 35, 25 ), dot( 1, 0.1, 0.1 ) ),
          diffuseBox( dot( 25, 35, 0 ), dot( 0.1, 0.1, 1 ) ),
          diffuseBox( dot( 25, 35, 25 ), dot( 1, 0.1, 1 ) ),
          diffuseBox( dot( 0, 10, 0 ), dot( 0.1, 1, 0.1 ) ),
          diffuseBox( dot( 0, 10, 25 ), dot( 1, 1, 0.1 ) ),
          diffuseBox( dot( 25, 10, 0 ), dot( 0.1, 1, 1 ) ),
          diffuseBox( dot( 25, 10, 25 ), dot( 1, 1, 1 ) ),
          new tess.Sphere( dot( -25, 12, -25 ), 12, false, new tess.SmoothDielectric( 1.5 ), true ),
          glassBox( dot( -50, 10, -50 ) ),
          diffuseBox( dot( -50, 10, -75 ), dot( 1, 0.1, 0.1 ) ),
          lightSphere
        ];
      }
      function useColorScene() {
        floor.material = diffuseFloorMaterial;
        sceneObs = colorSceneObs;
        updateSampleProgram();
      }

      function setupIndoorScene() {
        var indoorWallHeight = 150;

        var ceiling = new tess.Box3( dot( -wallOuter, indoorWallHeight, -wallOuter ), dot( wallOuter, indoorWallHeight + 2, wallOuter ), false, new tess.Attenuate( new tess.Diffuse(), dot( 1, 1, 1 ), false ) );

        // TODO: add actual window/windows? (dielectric)
        var wall1 = new tess.Box3( dot( -wallOuter, 0, wallInner ), dot( wallOuter, indoorWallHeight, wallOuter ), false, new tess.Attenuate( new tess.Diffuse(), dot( 0.9, 0.9, 0.9 ), false ) );
        var wall2 = new tess.Box3( dot( -wallOuter, 0, -wallOuter ), dot( wallOuter, wallHeight * 2 / 3, -wallInner ), false, new tess.Attenuate( new tess.Diffuse(), dot( 0.9, 0.9, 0.9 ), false ) );
        var wall2x = new tess.Box3( dot( -2, wallHeight, -wallOuter + 5 ), dot( 2, indoorWallHeight, -wallInner - 5 ), false, new tess.Attenuate( new tess.Diffuse(), dot( 0.9, 0.9, 0.9 ), false ) );
        var wall3 = new tess.Box3( dot( -wallOuter, 0, -wallOuter ), dot( -wallInner, indoorWallHeight, wallOuter ), false, new tess.Attenuate( new tess.Diffuse(), dot( 0.9, 0.9, 0.9 ), false ) );
        var wall4 = new tess.Box3( dot( wallInner, 0, -wallOuter ), dot( wallOuter, indoorWallHeight, wallOuter ), false, new tess.Attenuate( new tess.Diffuse(), dot( 0.9, 0.9, 0.9 ), false ) );

        var glassWindow = new tess.Box3( dot( -wallInner, wallHeight, -wallOuter + 8 ), dot( wallInner, indoorWallHeight, -wallInner - 8 ), false, new tess.SmoothDielectric( 1.5 ), true );

        var glassSphere = new tess.Sphere( dot( 90, 25, 0 ), 25, false, new tess.SmoothDielectric( 1.5 ), true );
        var blackSphere = new tess.Sphere( dot( 30, 25, 0 ), 25, false, new tess.ShinyBlack( 1.5167 ) );
        var metalSphere = new tess.Sphere( dot( -30, 25, 0 ), 25, false, new tess.Metal( dot( 2.1928, 3.9379 ) ) ); // like platinum
        var greenSphere = new tess.Sphere( dot( -90, 25, 0 ), 25, false, new tess.FresnelCompositeMaterial( new tess.Reflect(), new tess.Attenuate( new tess.Diffuse(), dot( 0.1, 1, 0.1 ), false ), tess.airIOR, 1.33 ) );


        indoorSceneObs = [
          floor,
          ceiling,
          wall1,
          wall2,
          wall3,
          wall4,
          lightSphere,
          glassSphere,
          blackSphere,
          metalSphere,
          greenSphere
        ];
      }
      function useIndoorScene() {
        floor.material = oakFloorMaterial;
        sceneObs = indoorSceneObs;
        updateSampleProgram();
      }

      setupCoffeeScene();
      setupTestScene();
      setupColorScene();
      setupIndoorScene();
      sceneObs = coffeeSceneObs;

      var environmentRotation = document.getElementById( 'environmentRotationSlider' ).value / 360;

      var compiledOk = false;
      var needsCompilation = true;
      var needsTexture = false;

      var environment = new tess.TextureEnvironment( envTexture, 'rectilinear', 3, environmentRotation, true );
      var projection = new tess.PerspectiveDepthRays( 150, 0 );

      var samplingProgram;
      var integrator = null;

      var camera = new tess.Camera3(
        dot( -138.4543984451003, 89.1664219061534, 93.61742672324178 ),
        new dot.Matrix3(
          -0.6250572204589844, 0.23142336308956146,  0.7454872727394104,
          0,                   0.9550415873527527,   -0.29647570848464966,
          -0.7805812358856201, -0.18531423807144165, -0.5969557166099548 ),
        function() {
          integrator && integrator.clear();
        }
      );

      function getRayFromCanvasCoordinates( canvasPoint ) {
        var p = canvasPoint.plusScalar( 0.5 ).dividedScalar( canvas.width ).minusScalar( 0.5 );
        p.y = -p.y;
        var dir = projection.getRayDir( camera.rotationMatrix, p ).normalized();
        return new dot.Ray3( camera.position, dir );
      }

      function initializeIntegrator() {
        console.log( 'new integrator' );
        integrator = new tess.TextureIntegrator( samplingProgram, function( program ) {
          gl.uniformMatrix3fv( program.uniformLocations.rotationMatrix, false, camera.rotationMatrix.entries );
          gl.uniform3f( program.uniformLocations.cameraPosition, camera.position.x, camera.position.y, camera.position.z );
          gl.uniform2f( program.uniformLocations.times, startTime, startTime + shutterOpenTime );
          for ( var i = 0; i < sceneObs.length; i++ ) {
            sceneObs[i].update( program );
            sceneObs[i].material.update( program );
          }
          projection.update( program );
          environment.update( program );
        }, canvas.width )
      }

      function updateSampleProgram() {
        setStatus( 'Compiling shader...' );

        needsCompilation = true;

        setTimeout( function() {
          needsCompilation = false;

          if ( samplingProgram ) {
            samplingProgram.dispose();
          }

          compiledOk = false;
          try {
            samplingProgram = tess.create2SceneProgram( sceneObs, projection, environment, ( sceneObs === testSceneObs || sceneObs === colorSceneObs ) ? 9 : 5 );
            compiledOk = true; // no exception
          } catch ( e ) {
            var str = e.toString();
            var idx = str.indexOf( 'attribute vec3 vertex' );
            if ( idx >= 0 ) {
              str = str.slice( 0, idx ) + '&lt;fragment source&gt;';
            }
            setStatus( str );
          }

          if ( !integrator ) {
            initializeIntegrator();
          }

          integrator.sampleProgram = samplingProgram;
          integrator.clear();

          window.console && console.log && samplingProgram && samplingProgram.fragmentSource && console.log( samplingProgram.fragmentSource );
        }, 50 );
      }

      var mouseRotateBox = document.getElementById( 'mouseRotateBox' );
      var mouseFocusBox = document.getElementById( 'mouseFocusBox' );
      var mouseLightBox = document.getElementById( 'mouseLightBox' );
      var mouseMakeDynamicBox = document.getElementById( 'mouseMakeDynamicBox' );

      function rayCast( ray, excludeObs ) {
        var bestDist = Number.POSITIVE_INFINITY;
        var bestOb = null;
        for ( var i = 0; i < sceneObs.length; i++ ) {
          if ( _.indexOf( excludeObs, sceneObs[i] ) === -1 ) {
            var t = sceneObs[i].hitTest( ray );
            if ( t < bestDist ) {
              bestDist = t;
              bestOb = sceneObs[i];
            }
          }
        }
        return {
          ob: bestOb,
          t: bestDist
        };
      }

      var draggedOb = null;
      var draggedOffset = null;
      var draggedRayOffset = null;

      function canvasPointFromEvent( evt ) {
        var canvasRect = canvas.getBoundingClientRect()
        return dot( evt.clientX - canvasRect.left, evt.clientY - canvasRect.top );
      }

      function rayFromEvent( evt ) {
        return getRayFromCanvasCoordinates( canvasPointFromEvent( evt ) );
      }

      function getCenterRay() {
        return new dot.Ray3( camera.position, projection.getRayDir( camera.rotationMatrix, dot( 0, 0 ) ).normalized() );
      }

      function sceneAction( evt ) {
        var ray = rayFromEvent( evt );

        var t;

        if ( mouseFocusBox.checked ) {
          t = rayCast( ray, [lightSphere] ).t;

          if ( !isFinite( t ) ) {
            t = 200000;
          }

          projection.focalLength = t;
          focalLengthSlider.value = t;
          integrator.clear();
        } else if ( mouseLightBox.checked ) {
          t = rayCast( ray, [lightSphere] ).t;

          if ( isFinite( t ) ) {
            lightSphere.center = ray.pointAtDistance( t );
            integrator.clear();
          }
        } else if ( mouseMakeDynamicBox.checked && !draggedOb && !mouseIsDown ) {
          var hit = rayCast( ray, [lightSphere] );
          if ( hit.ob instanceof tess.Sphere ) {
            // hit.ob.center = ray.pointAtDistance( floor.hitTest( ray ) ).plus( dot( 0, hit.ob.radius, 0 ) );
            if ( !hit.ob.isDynamic ) {
              hit.ob.isDynamic = true;
              hit.ob.refresh();
              updateSampleProgram();
            }
            integrator.clear();
            draggedOb = hit.ob;
            var hitPoint = ray.pointAtDistance( hit.t );
            draggedOffset = hit.ob.center.minus( hitPoint );
            draggedRayOffset = hitPoint.y;
          }
        }
      }
      var mousePos;

      var mouseIsDown = false;
      canvas.addEventListener( 'mousedown', function( evt ) {
        canvas.style.cursor = 'default';
        draggedOb = null;
        sceneAction( evt );
        mouseIsDown = true;
        mousePos = canvasPointFromEvent( evt );
      } );
      canvas.addEventListener( 'mouseup', function( evt ) {
        canvas.style.cursor = 'inherit';
        draggedOb = null;
        mouseIsDown = false;
      } );

      window.addEventListener( 'mousemove', function( evt ) {
        if ( mouseIsDown ) {
          sceneAction( evt );
          var newMousePos = canvasPointFromEvent( evt );
          if ( mouseRotateBox.checked ) {
            var delta = newMousePos.minus( mousePos );
            var dragScale = 0.005;
            var quat = dot.Quaternion.fromEulerAngles(
              delta.y * dragScale, // yaw
              delta.x * dragScale, // roll
              0                    // pitch
            );
            var focalPoint = getCenterRay().pointAtDistance( focalLengthSlider.value );
            camera.rotationMatrix.multiplyMatrix( quat.toRotationMatrix() );
            var newFocalPoint = getCenterRay().pointAtDistance( focalLengthSlider.value );
            camera.position = camera.position.minus( newFocalPoint.minus( focalPoint ) );
            integrator.clear();
          }
          mousePos = newMousePos;
        }
        if ( mouseMakeDynamicBox.checked && draggedOb && draggedOb.isDynamic ) {
          var ray = rayFromEvent( evt );
          var offsetRay = new dot.Ray3( ray.pos.copy(), ray.dir );
          offsetRay.pos.y -= draggedRayOffset;
          draggedOb.center = ray.pointAtDistance( floor.hitTest( offsetRay ) ).plus( draggedOffset );
          integrator.clear();
        }
      } );

      var brightnessSlider = document.getElementById( 'brightnessSlider' );
      brightnessSlider.addEventListener( 'input', function() {
        integrator.brightness = brightnessSlider.value / 100;
      } );

      var dofSpreadSlider = document.getElementById( 'dofSpreadSlider' );
      dofSpreadSlider.addEventListener( 'input', function() {
        projection.dofSpread = dofSpreadSlider.value / 25;
        integrator.clear();
      } );

      var focalLengthSlider = document.getElementById( 'focalLengthSlider' );
      focalLengthSlider.addEventListener( 'input', function() {
        projection.focalLength = focalLengthSlider.value;
        integrator.clear();
      } );

      var linearBox = document.getElementById( 'linearBox' );
      linearBox.addEventListener( 'click', function() {
        integrator.quadProgram = tess.textureQuadGammaProgram;
      } );

      var reinhardBox = document.getElementById( 'reinhardBox' );
      reinhardBox.addEventListener( 'click', function() {
        integrator.quadProgram = tess.textureQuadReinhardProgram;
      } );

      var filmicBox = document.getElementById( 'filmicBox' );
      filmicBox.addEventListener( 'click', function() {
        integrator.quadProgram = tess.textureQuadFilmicProgram;
      } );

      var isStereographic = false;

      var perspectiveBox = document.getElementById( 'perspectiveBox' );
      perspectiveBox.addEventListener( 'click', function() {
        if ( isStereographic ) {
          isStereographic = false;
          projection = new tess.PerspectiveDepthRays( focalLengthSlider.value, 0 );
          projection.dofSpread = dofSpreadSlider.value / 100;
          projection.focalLength = focalLengthSlider.value;
          updateSampleProgram();
        }
      } );

      var stereographicBox = document.getElementById( 'stereographicBox' );
      stereographicBox.addEventListener( 'click', function() {
        if ( !isStereographic ) {
          isStereographic = true;
          projection = new tess.StereographicRays();
          updateSampleProgram();
        }
      } );

      var envConstantBox = document.getElementById( 'envConstantBox' );
      envConstantBox.addEventListener( 'click', function() {
        environment = new tess.ProceduralEnvironment( 'accumulation = accumulation + attenuation * 1.5;\n', [] );
        updateSampleProgram();
      } );

      var customGLSLText = document.getElementById( 'customGLSLText' );
      var envWeirdBox = document.getElementById( 'envWeirdBox' );
      function updateGLSL() {
        var expr = customGLSLText.value;
        environment = new tess.ProceduralEnvironment( 'accumulation = accumulation + attenuation * ( ' + expr + ' );\n', [] );
        updateSampleProgram();
      }
      envWeirdBox.addEventListener( 'click', updateGLSL );
      var updateCustomGLSLButton = document.getElementById( 'updateCustomGLSLButton' );
      updateCustomGLSLButton.addEventListener( 'click', updateGLSL );

      function lazyLoadEnvironmentTexture( url, width, height, type, multiplier, isHalf ) {
        if ( needsTexture ) {
          return; // bleh, better way to just use the latest?
        }
        gl.deleteTexture( envTexture );

        setStatus( 'Loading Texture...' );
        needsTexture = true;
        tess.asyncLoadHDRTexture( tess.gl, url, width, height, false, tess.gl.RGB, function( texture ) {
          window.envTexture = texture;
          needsTexture = false;
          setStatus();

          environment = new tess.TextureEnvironment( window.envTexture, type, multiplier, environmentRotation, isHalf );
          updateSampleProgram();
        } );
      }

      // vizpeople skies
      _.each( ['01','02','03','04','05','06','07','08','09','10'], function( id ) {
        document.getElementById( 'envTest' + id ).addEventListener( 'click', function() {
          lazyLoadEnvironmentTexture( '../../images/hdrTest' + id + '_2half.hdr', 2048, 512, 'rectilinear', vizpeopleEnvironments[id].brightness, true );
        } );
        document.getElementById( 'envTest' + id + 'x' ).addEventListener( 'click', function() {
          lazyLoadEnvironmentTexture( '../../images/hdrTest' + id + '_1half.hdr', 4096, 1024, 'rectilinear', vizpeopleEnvironments[id].brightness, true );
        } );
      } );

      document.getElementById( 'envDusk2048Box' ).addEventListener( 'click', function() {
        lazyLoadEnvironmentTexture( '../../images/colorsf2half.hdr', 2048, 512, 'rectilinear', 3, true );
      } );

      var environmentRotationSlider = document.getElementById( 'environmentRotationSlider' );
      environmentRotationSlider.addEventListener( 'input', function() {
        environment.rotation = environmentRotation = environmentRotationSlider.value / 360;
        integrator.clear();
      } );

      // var sceneCoffeeBox = document.getElementById( 'sceneCoffeeBox' );
      // sceneCoffeeBox.addEventListener( 'click', function() {
      //   useCoffeeScene();
      // } );

      // var sceneTestBox = document.getElementById( 'sceneTestBox' );
      // sceneTestBox.addEventListener( 'click', function() {
      //   useTestScene();
      // } );

      // var sceneIndoorBox = document.getElementById( 'sceneIndoorBox' );
      // sceneIndoorBox.addEventListener( 'click', function() {
      //   useIndoorScene();
      // } );

      // var sceneColorBox = document.getElementById( 'sceneColorBox' );
      // sceneColorBox.addEventListener( 'click', function() {
      //   useColorScene();
      // } );

      var size256Box = document.getElementById( 'size256Box' );
      size256Box.addEventListener( 'click', function() {
        if ( canvas.width !== 256 ) {
          var idx = window.location.href.indexOf( '?' );
          window.location = window.location.href.slice( 0, idx > 0 ? idx : window.location.href.length ) + '?size=256';
        }
      } );

      var size512Box = document.getElementById( 'size512Box' );
      size512Box.addEventListener( 'click', function() {
        if ( canvas.width !== 512 ) {
          var idx = window.location.href.indexOf( '?' );
          window.location = window.location.href.slice( 0, idx > 0 ? idx : window.location.href.length ) + '?size=512';
        }
      } );

      var size1024Box = document.getElementById( 'size1024Box' );
      size1024Box.addEventListener( 'click', function() {
        if ( canvas.width !== 1024 ) {
          var idx = window.location.href.indexOf( '?' );
          window.location = window.location.href.slice( 0, idx > 0 ? idx : window.location.href.length ) + '?size=1024';
        }
      } );

      var startTimeSlider = document.getElementById( 'startTimeSlider' );
      startTimeSlider.addEventListener( 'input', function() {
        startTime = Number.parseFloat( startTimeSlider.value );
        integrator.clear();
      } );

      var shutterOpenTimeSlider = document.getElementById( 'shutterOpenTimeSlider' );
      shutterOpenTimeSlider.addEventListener( 'input', function() {
        shutterOpenTime = Number.parseFloat( shutterOpenTimeSlider.value );
        integrator.clear();
      } );

      updateSampleProgram();

      camera.initializeKeyboardControl();

      var lastTime = Date.now();

      var samplerSteps = 1;
      var actualSamplerSteps = 1;

      (function step() {
        window.requestAnimationFrame( step );

        if ( needsCompilation || needsTexture ) {
          return;
        }

        var currentTime = Date.now();
        var timeElapsed = currentTime - lastTime;
        lastTime = currentTime;

        camera.step( timeElapsed );

        if ( compiledOk ) {
          setStatus();

          if ( timeElapsed > 18 ) {
            var factor = ( 18 / timeElapsed );
            samplerSteps = Math.max( 1, samplerSteps * factor );
          } else {
            samplerSteps += 0.2;
          }
          actualSamplerSteps = 0.8 * actualSamplerSteps + 0.2 * samplerSteps;

          var steps = Math.max( 1, Math.floor( actualSamplerSteps ) );
          for ( var i = 0; i < steps; i++ ) {
            integrator.step();
          }
          integrator.render();
          customGLSLText.style.background = '';
        } else {
          customGLSLText.style.background = 'rgba(255,0,0,0.2)';
        }
      })();
    }
    window.addEventListener( 'load', function() {
      if ( !tess.gl ) {
        setStatus( 'Error: ' + window.failureMessage );
      } else {
        setStatus( 'Loading Texture...' );
        tess.asyncLoadHDRTexture( tess.gl, '../../images/hdrTest04_2half.hdr', 2048, 512, false, tess.gl.RGB, function( texture ) {
          window.envTexture = texture;

          initialize();
        } );
      }
    } );
  </script>
  <a href="https://github.com/jonathanolson/tesserace"><img style="position: absolute; top: 0; right: 0; border: 0; z-index: 40;" alt="Fork me on GitHub" src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"></a>
  <img class="hidden" src="../../images/oak1-diffuse-2048.jpg" alt="oak1-diffuse-2048" id="oak1-diffuse-2048"/>
  <img class="hidden" src="../../images/oak1-dirt-2048.jpg" alt="oak1-dirt-2048" id="oak1-dirt-2048"/>
  <img class="hidden" src="../../images/oak1-dot3-4096.jpg" alt="oak1-dot3-4096" id="oak1-dot3-4096"/>
</body>
</html>
